from abc import ABC, abstractmethod
import logging
import node_tools as nt


class FlowSnippet(object):
    '''A piece of flow with a single entry and exit point.

    FlowSnippets are generated by `FlowEditOp`s and replace an original input
    node. A flow snippet may contain multiple variations of the input node,
    which are specifically recorded so that further `FlowEditOp`s can be
    applied to those nodes.

    Args:
        nodes: List of nodes defining the flow snippet
        node_variations: Nodes that are variations of the original node
        root_uuid: Everything previously having the original node
            as destination is redirected to root_uuid
    '''

    def __init__(self, nodes, node_variations, root_uuid=-1):
        self._nodes = nodes
        self._node_variations = node_variations
        if root_uuid == -1:
            self._root_uuid = nodes[0]["uuid"]
        else:
            self._root_uuid = root_uuid

    def nodes(self):
        return self._nodes

    def node_variations(self):
        return self._node_variations

    def root_uuid(self):
        return self._root_uuid


class FlowEditOp(ABC):

    def needs_parameter():
        '''Does this operation read a value from the "change" column?'''
        return True

    def create_edit_op(op_type, flow_id, row_id, orig_msg, bit_of_text,
                       split_by, default_text, debug_string,
                       has_node_for_other_category=True,
                       assign_to_group=False):
        if op_type not in OPERATION_TYPES:
            logging.warning(debug_string + 'invalid operation type.')
            return None
        class_name = OPERATION_TYPES[op_type]
        return class_name(flow_id, row_id, orig_msg, bit_of_text, split_by,
                          default_text, debug_string,
                          has_node_for_other_category, assign_to_group)

    def __init__(self, flow_id, row_id, orig_msg, bit_of_text, split_by,
                 default_text, debug_string,
                 has_node_for_other_category=True,
                 assign_to_group=False):
        self._flow_id = flow_id
        self._row_id = row_id
        self._orig_msg = orig_msg
        self._bit_of_text = bit_of_text
        self._split_by = split_by
        self._default_text = default_text
        self._categories = []
        self._debug_string = debug_string
        self._has_node_for_other_category = has_node_for_other_category
        self._assign_to_group = assign_to_group  # to be removed

    def add_category(self, category):
        self._categories.append(category)

    @abstractmethod
    def is_match_for_node(self, node):
        pass

    def apply_operation(self, flow, node):
        '''Apply the operation to a given node.

        Replaces the node with an appropriate flow snippet.

        Returns:
            list of nodes: variations of the input node that further
                operations can be applied to.
        '''

        uuid = node["uuid"]
        node_is_entrypoint = flow["nodes"][0]["uuid"] == uuid
        incoming_edges = nt.find_incoming_edges(flow, uuid)

        flow["nodes"].remove(node)
        snippet = self._get_flow_snippet(node)

        # Insert the new snippet.
        # If node was entrypoint, snippet has to become entrypoint
        if node_is_entrypoint:
            flow["nodes"] = snippet.nodes() + flow["nodes"]
        else:
            flow["nodes"] += flow["nodes"] + snippet.nodes()

        # Redirect edges that went into the node to the snippet root
        for edge in incoming_edges:
            edge["destination_uuid"] = snippet.root_uuid()
        
        return snippet.node_variations()

    def debug_string(self):
        '''Returns a human-readable identifier of sheet/row of the FlowEditOp.'''
        return self._debug_string

    def is_match_for_flow(self, flow_name):
        return flow_name == self._flow_id

    def flow_id(self):
        return self._flow_id

    def row_id(self):
        return self._row_id

    def orig_msg(self):
        return self._orig_msg

    def bit_of_text(self):
        return self._bit_of_text

    def split_by(self):
        return self._split_by

    def default_text(self):
        return self._default_text

    def categories(self):
        return self._categories

    def assign_to_group(self):
        return self._assign_to_group  # to be removed

    def has_node_for_other_category(self):
        return self._has_node_for_other_category

    @abstractmethod
    def _get_flow_snippet(self, node):
        pass

    def _matches_message_text(self, node):
        # TODO: Check row_id once implemented
        # TODO: If there are multiple exits, warn and return False
        for action in node["actions"]:
            if action["type"] == "send_msg" and action["text"] == self.orig_msg():
                return True
        return False

    def _matches_save_value(self, node):
        # TODO: Check row_id once implemented
        # TODO: If there are multiple exits, warn and return False
        for action in node["actions"]:
            if action["type"] == "send_msg" and action["text"] == self.orig_msg():
                return True
        return False

    def _replace_text_in_message(self, node, replacement_text):
        '''Modifies the input node by replacing message text.'''
        total_occurrences = 0
        for action in node["actions"]:
            if action["type"] == "send_msg":
                text = action["text"]
                total_occurrences += text.count(self.bit_of_text())
                text_new = text.replace(self.bit_of_text(), replacement_text)
                action["text"] = text_new
        # TODO: If we don't just store the node uuid, but also action uuid
        #   where edit_op is applicable, we could give more helpful
        #   messages here by referring to the action text that doesn't match
        if total_occurrences == 0:
            # This might happen if we're trying to replace text that has
            # already had a replacement applied to it.
            logging.warning(self.debug_string() + 'No occurrences of "{}" found node.'.format(self.bit_of_text()))
        if total_occurrences >= 2:
            logging.warning(self.debug_string() + 'Multiple occurrences of "{}" found in node.'.format(self.bit_of_text()))

    def _replace_text_in_quick_replies(self, node, replacement_text):
        '''Modifies the input node by replacing message text.

        Args:
            replacement_text (str): Semicolon separated list of text pieces.
        '''

        for bit_of_text, repl_text in zip(self._bit_of_text.split(';'), replacement_text.split(';')):
            total_occurrences = 0
            for action in node["actions"]:
                if action["type"] == "send_msg":
                    for i, text in enumerate(action["quick_replies"]):
                        total_occurrences += text.count(bit_of_text)
                        text_new = text.replace(bit_of_text, repl_text)
                        action["quick_replies"][i] = text_new
            if total_occurrences == 0:
                logging.warning(self.debug_string() + 'No occurrences of "{}" found node.'.format(bit_of_text))
            if total_occurrences >= 2:
                logging.warning(self.debug_string() + 'Multiple occurrences of "{}" found in node.'.format(bit_of_text))

    def _apply_noop(self, node):
        return FlowSnippet([node], [node], node["uuid"])

    def _get_assigntogroup_gadget(self, node):
        if len(self.categories()) != 2:
            logging.warning(self.debug_string() + 'assign_to_group only for A/B tests (i.e. 2 groups).')
            return self._apply_noop(node)
        groupA_uuid = self.categories()[0].condition_arguments[0]
        groupA_name = self.categories()[0].condition_arguments[1]
        groupB_uuid = self.categories()[1].condition_arguments[0]
        groupB_name = self.categories()[1].condition_arguments[1]
        gadget = nt.get_assign_to_group_gadget(groupA_name, groupA_uuid, groupB_name, groupB_uuid, node["uuid"])
        return gadget

    def _get_variation_tree_snippet(self, input_node):
        node_variations = []
        for category in self.categories():
            node = nt.get_unique_node_copy(input_node)
            self._replace_text_in_node(node, category.replacement_text)
            node_variations.append(node)
        # Original variation serves as default option
        self._replace_text_in_node(input_node, self.default_text())

        if self.has_node_for_other_category():
            # Original input_node becomes the "Other" variation
            node_variations.append(input_node)
            destination_uuids = [node["uuid"] for node in node_variations]
        else:
            # Ditch the first variation and use the original instead.
            # No variation for the "Other" category is added.
            node_variations = [input_node] + node_variations[1:]
            # We reroute the "Other" category to first node variation
            destination_uuids = [node["uuid"] for node in node_variations] + [node_variations[0]["uuid"]]

        # TODO: Special case if categories are empty -> unconditional replace
        switch_node = nt.get_switch_node(self, destination_uuids)
        first_node = switch_node
        all_nodes = [switch_node] + node_variations

        if self.assign_to_group():
            gadget = self._get_assigntogroup_gadget(first_node)
            first_node = gadget[0]
            all_nodes = gadget + all_nodes

        return FlowSnippet(all_nodes, node_variations, first_node["uuid"])


class AssignToGroupBeforeMsgFlowEditOp(FlowEditOp):

    def needs_parameter():
        return False

    def is_match_for_node(self, node):
        return self._matches_message_text(node)

    def _get_flow_snippet(self, node):
        gadget = self._get_assigntogroup_gadget(node)
        all_nodes = gadget + [node]
        return FlowSnippet(all_nodes, [node], gadget[0]["uuid"])


class ReplaceBitOfTextFlowEditOp(FlowEditOp):

    def is_match_for_node(self, node):
        return self._matches_message_text(node)

    def _replace_text_in_node(self, node, text):
        self._replace_text_in_message(node, text)

    def _get_flow_snippet(self, input_node):
        return self._get_variation_tree_snippet(input_node)


class ReplaceQuickReplyFlowEditOp(FlowEditOp):

    def is_match_for_node(self, node):
        return self._matches_message_text(node)

    def _replace_text_in_node(self, node, text):
        self._replace_text_in_quick_replies(node, text)

    def _get_flow_snippet(self, input_node):
        return self._get_variation_tree_snippet(input_node)

# In the future, each class has an ID string, and the dict is autogenerated?
OPERATION_TYPES = {
    "replace_bit_of_text" : ReplaceBitOfTextFlowEditOp,
    "assign_to_group_before_msg_node" : AssignToGroupBeforeMsgFlowEditOp,
    "replace_quick_replies" : ReplaceQuickReplyFlowEditOp,
}